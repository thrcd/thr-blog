
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/thrcd/thr-blog/cmd/web/handlers.go (100.0%)</option>
				
				<option value="file1">github.com/thrcd/thr-blog/cmd/web/helpers.go (92.2%)</option>
				
				<option value="file2">github.com/thrcd/thr-blog/cmd/web/main.go (0.0%)</option>
				
				<option value="file3">github.com/thrcd/thr-blog/cmd/web/routes.go (0.0%)</option>
				
				<option value="file4">github.com/thrcd/thr-blog/cmd/web/template.go (73.0%)</option>
				
				<option value="file5">github.com/thrcd/thr-blog/internal/parser/parser.go (96.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "net/http"
        "text/template"
)

var (
        ErrIBrokeSomething = errors.New("sorry, I probably broke something")
)

type handlers struct {
        templateCache map[string]*template.Template
}

func (h *handlers) handlePosts(postsDir string) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                dirs := getSubDirs(postsDir)
                if dirs == nil </span><span class="cov8" title="1">{
                        h.empty(w)
                        return
                }</span>

                <span class="cov8" title="1">postListItems := getPostListItems(dirs)

                // DirNames represent the subsections on the posts page.
                // In this case, 2024, 2025...
                dirNames := maps(dirs, func(item string) string </span><span class="cov8" title="1">{ return lastSubString(item, "/") }</span>)

                <span class="cov8" title="1">data := newTemplateData()
                data.Dirs = dirNames
                data.PostListItems = postListItems

                render(w, "posts.tmpl", h.templateCache, data)</span>
        }
}

func (h *handlers) handlePost(postDir string) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{

                fn := r.PathValue("fn")
                currentDir := r.PathValue("dir")
                filePath := postDir + "/" + currentDir + "/" + fn + ".md"

                md, err := getMarkdown(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        h.serverError(w)
                        return
                }</span>

                <span class="cov8" title="1">data := newTemplateData()
                data.Markdown = md

                render(w, "post.tmpl", h.templateCache, data)</span>
        }
}

func (h *handlers) handleAbout(aboutDir string) http.HandlerFunc <span class="cov8" title="1">{
        filePath := aboutDir + "/" + "about.md"

        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                md, err := getMarkdown(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        h.serverError(w)
                        return
                }</span>

                <span class="cov8" title="1">data := newTemplateData()
                data.Markdown = md
                render(w, "about.tmpl", h.templateCache, data)</span>
        }
}

func (h *handlers) serverError(w http.ResponseWriter) <span class="cov8" title="1">{
        data := newTemplateData()
        data.Error = ErrIBrokeSomething.Error()
        renderError(w, "error.tmpl", h.templateCache, data)
}</span>

func (h *handlers) empty(w http.ResponseWriter) <span class="cov8" title="1">{
        data := newTemplateData()
        render(w, "empty.tmpl", h.templateCache, data)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        blog "github.com/thrcd/thr-blog"
        "github.com/thrcd/thr-blog/internal/parser"
        "sort"
        "strings"
)

func getSubDirs(root string) []string <span class="cov8" title="1">{
        dirs, err := blog.Cfs.ReadDir(root)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">postsDirs := make([]string, 0)
        for _, dir := range dirs </span><span class="cov8" title="1">{
                if dir.IsDir() </span><span class="cov8" title="1">{
                        url := root + "/" + dir.Name()
                        postsDirs = append(postsDirs, url)
                }</span>
        }

        <span class="cov8" title="1">return postsDirs</span>
}

func getFilePaths(dir string) ([]string, error) <span class="cov8" title="1">{
        files, err := blog.Cfs.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">paths := make([]string, 0)
        for _, file := range files </span><span class="cov8" title="1">{
                if !file.IsDir() </span><span class="cov8" title="1">{
                        paths = append(paths, dir+"/"+file.Name())
                }</span>
        }

        <span class="cov8" title="1">return paths, nil</span>
}

func lastSubString(path, delim string) string <span class="cov8" title="1">{
        i := strings.LastIndex(path, delim)
        return path[i+1:]
}</span>

func maps[T, V any](ts []T, fn func(T) V) []V <span class="cov8" title="1">{
        result := make([]V, len(ts))
        for i, t := range ts </span><span class="cov8" title="1">{
                result[i] = fn(t)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func getPostListItems(dirs []string) map[string][]postListItem <span class="cov8" title="1">{
        collection := make(map[string][]postListItem)

        sort.Slice(dirs, func(i, j int) bool </span><span class="cov0" title="0">{
                return dirs[i] &gt; dirs[j]
        }</span>)

        <span class="cov8" title="1">for _, dir := range dirs </span><span class="cov8" title="1">{
                paths, err := getFilePaths(dir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">curDir := lastSubString(dir, "/")

                posts := make([]postListItem, 0)
                for _, path := range paths </span><span class="cov8" title="1">{
                        file, err := blog.Cfs.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov8" title="1">filename := lastSubString(path, "/")
                        metadata := parser.ParseMetadata(file)

                        postItem := postListItem{
                                Filename: filename,
                                Metadata: metadata,
                        }

                        posts = append(posts, postItem)</span>
                }

                <span class="cov8" title="1">sort.Slice(posts, func(i, j int) bool </span><span class="cov8" title="1">{
                        return posts[j].Metadata.Date.Before(posts[i].Metadata.Date)
                }</span>)

                <span class="cov8" title="1">collection[curDir] = posts</span>
        }

        <span class="cov8" title="1">return collection</span>
}

func getMarkdown(filePath string) (parser.Markdown, error) <span class="cov8" title="1">{
        file, err := blog.Cfs.ReadFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return parser.Markdown{}, err
        }</span>

        <span class="cov8" title="1">md, err := parser.ParseMarkdown(file)
        if err != nil </span><span class="cov0" title="0">{
                return parser.Markdown{}, err
        }</span>

        <span class="cov8" title="1">return md, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "flag"
        "log/slog"
        "net/http"
        "os"
        "time"
)

const postsFS = "content/blog/posts"
const blogFS = "content/blog"

func main() <span class="cov0" title="0">{
        addr := flag.String("addr", ":4000", "HTTP network address")
        log := slog.New(slog.NewJSONHandler(os.Stdout, nil))

        server := &amp;http.Server{
                Addr:         *addr,
                Handler:      routes(),
                IdleTimeout:  time.Minute,
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
        }

        log.Info("starting server", slog.String("addr", server.Addr))
        err := server.ListenAndServe()

        log.Error(err.Error())
        os.Exit(1)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "github.com/thrcd/thr-blog/internal/ui"
        "net/http"
        "os"
)

func routes() http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()

        templateCache, err := newTemplateCache()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("got err: %s", ErrCreateTemplateCache)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">handlers := handlers{templateCache: templateCache}

        mux.Handle("GET /static/", http.StripPrefix("/static/",
                http.FileServer(http.FS(ui.StaticFS)),
        ))

        mux.HandleFunc("GET /", handlers.handlePosts(postsFS))
        mux.HandleFunc("GET /post/{dir}/{fn}", handlers.handlePost(postsFS))
        mux.HandleFunc("GET /about", handlers.handleAbout(blogFS))

        return mux</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "bytes"
        "errors"
        "fmt"
        "github.com/thrcd/thr-blog/internal/parser"
        "github.com/thrcd/thr-blog/internal/ui"
        "io/fs"
        "net/http"
        "path/filepath"
        "strconv"
        "strings"
        "text/template"
        "time"
)

var (
        ErrCreateTemplateCache = errors.New("can not create a new template cache")
)

type postListItem struct {
        Filename string
        Metadata parser.Metadata
}

type templateData struct {
        Dirs          []string
        PostListItems map[string][]postListItem
        Markdown      parser.Markdown
        CurrentDate   time.Time
        Error         string
}

func newTemplateData() templateData <span class="cov8" title="1">{
        return templateData{
                CurrentDate: time.Now(),
        }
}</span>

func newTemplateCache() (map[string]*template.Template, error) <span class="cov8" title="1">{
        cache := map[string]*template.Template{}

        pages, err := fs.Glob(ui.Files, "html/pages/*.tmpl")

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, page := range pages </span><span class="cov8" title="1">{
                name := filepath.Base(page)

                patterns := []string{
                        "html/base.tmpl",
                        "html/partials/*.tmpl",
                        page,
                }

                ts, err := template.New(name).Funcs(functions).ParseFS(ui.Files, patterns...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">cache[name] = ts</span>
        }

        <span class="cov8" title="1">return cache, nil</span>
}

// Rendering

func render(w http.ResponseWriter, page string, template map[string]*template.Template, data templateData) <span class="cov8" title="1">{
        ts, ok := template[page]

        if !ok </span><span class="cov0" title="0">{
                fmt.Errorf("the template %s does not exist", page)
                return
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        err := ts.ExecuteTemplate(buf, "base", data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">buf.WriteTo(w)</span>
}

func renderError(w http.ResponseWriter, page string, template map[string]*template.Template, data templateData) <span class="cov8" title="1">{
        ts, ok := template[page]

        if !ok </span><span class="cov0" title="0">{
                fmt.Errorf("the template %s does not exist", page)
                return
        }</span>

        <span class="cov8" title="1">buf := new(bytes.Buffer)
        err := ts.ExecuteTemplate(w, "error", data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">_, _ = buf.WriteTo(w)</span>
}

// Template Functions

func humanDate(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return t.UTC().Format("02 Jan 2006")</span>
}

func year(t time.Time) string <span class="cov0" title="0">{
        return strconv.Itoa(t.Year())
}</span>

func cleanMarkdownExt(fn string) string <span class="cov8" title="1">{
        return strings.TrimSuffix(fn, ".md")
}</span>

func lowcase(str string) string <span class="cov8" title="1">{
        return strings.ToLower(str)
}</span>

var functions = template.FuncMap{
        "humanDate":        humanDate,
        "cleanMarkdownExt": cleanMarkdownExt,
        "year":             year,
        "lowcase":          lowcase,
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package parser

import (
        "bufio"
        "bytes"
        "github.com/russross/blackfriday/v2"
        "regexp"
        "strings"
        "time"
)

var (
        metaTitleReg = regexp.MustCompile(`(?i)title\s*=\s*"([^"]+)"`)
        metaDateReg  = regexp.MustCompile(`(?i)date\s*=\s*"([^"]+)"`)
        metaTagsReg  = regexp.MustCompile(`tags\s*=\s*\[([^\]]*)\]`)
        metaDelimReg = regexp.MustCompile(`\++`)
)

type Metadata struct {
        Title string
        Date  time.Time
        Tags  []interface{}
}

type Markdown struct {
        Metadata Metadata
        Body     string
}

func ParseMetadata(b []byte) Metadata <span class="cov8" title="1">{
        reader := bytes.NewReader(b)
        var metadata Metadata
        metaDelimCounter := 0

        scanner := bufio.NewScanner(reader)

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := bytes.TrimSpace(scanner.Bytes())

                if metaDelimReg.Match(line) </span><span class="cov8" title="1">{
                        metaDelimCounter++
                }</span>

                <span class="cov8" title="1">if metaDelimCounter &gt; 1 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">ok, titleMatch := getMetadataString(metaTitleReg, line)
                if ok </span><span class="cov8" title="1">{
                        metadata.Title = titleMatch
                }</span>

                <span class="cov8" title="1">ok, dateStr := getMetadataString(metaDateReg, line)
                if ok </span><span class="cov8" title="1">{
                        date, err := time.Parse("2006-01-02", dateStr)
                        if err == nil </span><span class="cov8" title="1">{
                                metadata.Date = date
                        }</span>
                }

                <span class="cov8" title="1">ok, tagsMatch := getMetadataSlice(metaTagsReg, line)
                if ok </span><span class="cov8" title="1">{
                        metadata.Tags = tagsMatch
                }</span>
        }

        <span class="cov8" title="1">if metadata.Date.IsZero() </span><span class="cov0" title="0">{
                metadata.Date = time.Now()
        }</span>

        <span class="cov8" title="1">return metadata</span>
}

func ParseMarkdown(file []byte) (Markdown, error) <span class="cov8" title="1">{
        var markdown Markdown
        var buf bytes.Buffer

        // Checks if file has metadata. If positive, it parses the metadata and assign to markdown.
        if len(file) != 0 &amp;&amp; metaDelimReg.Match(file[:1]) </span><span class="cov8" title="1">{
                //var inMetadata bool
                var line []byte
                var lastDelimIndex int
                var metaDelimCounter int

                markdown.Metadata = ParseMetadata(file)

                reader := bytes.NewReader(file)
                scanner := bufio.NewScanner(reader)

                // Scans the files and increments the lastDelimIndex counter until it finds the last occurrence of "+++".
                // This counter will be used to skip over the metadata when parsing the markdown.
                for i := 0; scanner.Scan(); i++ </span><span class="cov8" title="1">{
                        line = bytes.TrimSpace(scanner.Bytes())
                        lastDelimIndex += len(line) + len("\n")

                        if metaDelimReg.Match(line) </span><span class="cov8" title="1">{
                                metaDelimCounter++
                        }</span>

                        <span class="cov8" title="1">if metaDelimCounter &gt; 1 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                // File now has only the markdown content without metadata
                <span class="cov8" title="1">file = file[lastDelimIndex:]

                if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{ // Checked scanner error
                        return Markdown{}, err
                }</span>
        }

        <span class="cov8" title="1">var bodyBuf bytes.Buffer
        if buf.Len() == 0 </span><span class="cov8" title="1">{
                buf.Write(file)
        }</span>

        <span class="cov8" title="1">md := blackfriday.Run(file)
        bodyBuf.Write(md)
        markdown.Body = bodyBuf.String()

        return markdown, nil</span>
}

func getMetadataString(rgx *regexp.Regexp, b []byte) (bool, string) <span class="cov8" title="1">{
        matches := rgx.FindSubmatch(b)

        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return true, string(matches[1])
        }</span>

        <span class="cov8" title="1">return false, ""</span>
}

func getMetadataSlice(rgx *regexp.Regexp, b []byte) (bool, []interface{}) <span class="cov8" title="1">{
        matches := rgx.FindSubmatch(b)

        sl := make([]interface{}, 0)
        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                str := string(matches[1])
                str = strings.ReplaceAll(str, "\"", "")
                strs := strings.Split(str, ",")
                for _, s := range strs </span><span class="cov8" title="1">{
                        sl = append(sl, s)
                }</span>

                <span class="cov8" title="1">return true, sl</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
